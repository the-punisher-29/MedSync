{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport class Anatomy {\n  constructor(name) {\n    var _this = this;\n    this.name = name;\n    _defineProperty(this, \"map\", {});\n    _defineProperty(this, \"called\", false);\n    _defineProperty(this, \"assert\", () => {\n      if (!this.called) {\n        this.called = true;\n        return;\n      }\n      throw new Error(\"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\");\n    });\n    _defineProperty(this, \"parts\", function () {\n      _this.assert();\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n      for (var part of values) {\n        ;\n        _this.map[part] = _this.toPart(part);\n      }\n      return _this;\n    });\n    _defineProperty(this, \"extend\", function () {\n      for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        parts[_key2] = arguments[_key2];\n      }\n      for (var part of parts) {\n        if (part in _this.map) continue;\n        _this.map[part] = _this.toPart(part);\n      }\n      return _this;\n    });\n    _defineProperty(this, \"toPart\", part => {\n      var el = [\"container\", \"root\"].includes(part != null ? part : \"\") ? [this.name] : [this.name, part];\n      var attr = el.filter(Boolean).join(\"__\");\n      var className = \"chakra-\" + attr;\n      var partObj = {\n        className,\n        selector: \".\" + className,\n        toString: () => part\n      };\n      return partObj;\n    });\n    _defineProperty(this, \"__type\", {});\n  }\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  get selectors() {\n    var value = Object.fromEntries(Object.entries(this.map).map(_ref => {\n      var [key, part] = _ref;\n      return [key, part.selector];\n    }));\n    return value;\n  }\n  /**\n   * Get all classNames for the component anatomy\n   */\n\n  get classNames() {\n    var value = Object.fromEntries(Object.entries(this.map).map(_ref2 => {\n      var [key, part] = _ref2;\n      return [key, part.className];\n    }));\n    return value;\n  }\n  /**\n   * Get all parts as array of string\n   */\n\n  get keys() {\n    return Object.keys(this.map);\n  }\n  /**\n   * Creates the part object for the given part\n   */\n}\nexport function anatomy(name) {\n  return new Anatomy(name);\n}","map":{"version":3,"sources":["../../src/anatomy.ts"],"names":["Anatomy","constructor","name","called","Error","values","assert","part","map","toPart","parts","selectors","value","fromEntries","entries","key","selector","classNames","className","keys","Object","el","includes","attr","filter","Boolean","join","partObj","toString","anatomy"],"mappings":"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","sourcesContent":["/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport class Anatomy<T extends string = string> {\n  private map: Record<T, Part> = {} as Record<T, Part>\n  private called = false\n\n  constructor(private name: string) {}\n\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n  private assert = () => {\n    if (!this.called) {\n      this.called = true\n      return\n    }\n\n    throw new Error(\n      \"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\",\n    )\n  }\n\n  /**\n   * Add the core parts of the components\n   */\n  public parts = <V extends string>(...values: V[]) => {\n    this.assert()\n    for (const part of values) {\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<V>, \"parts\">\n  }\n\n  /**\n   * Extend the component anatomy to includes new parts\n   */\n  public extend = <U extends string>(...parts: U[]) => {\n    for (const part of parts) {\n      if (part in this.map) continue\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<T | U>, \"parts\">\n  }\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  get selectors() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).selector,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all classNames for the component anatomy\n   */\n  get classNames() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).className,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all parts as array of string\n   */\n  get keys() {\n    return Object.keys(this.map) as T[]\n  }\n\n  /**\n   * Creates the part object for the given part\n   */\n  toPart = (part: string) => {\n    const el = [\"container\", \"root\"].includes(part ?? \"\")\n      ? [this.name]\n      : [this.name, part]\n    const attr = el.filter(Boolean).join(\"__\")\n    const className = `chakra-${attr}`\n\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part,\n    }\n\n    return partObj as typeof partObj & string\n  }\n\n  /**\n   * Used to get the derived type of the anatomy\n   */\n  __type = {} as T\n}\n\ntype Part = {\n  className: string\n  selector: string\n  toString: () => string\n}\n\nexport function anatomy(name: string) {\n  return new Anatomy(name)\n}\n"]},"metadata":{},"sourceType":"module"}