{"ast":null,"code":"export function getFirstItem(array) {\n  return array != null && array.length ? array[0] : undefined;\n}\nexport function getLastItem(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\nexport function getPrevItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n  var prevIndex = getPrevIndex(index, array.length, loop);\n  return array[prevIndex];\n}\nexport function getNextItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n  var nextIndex = getNextIndex(index, array.length, 1, loop);\n  return array[nextIndex];\n}\nexport function removeIndex(array, index) {\n  return array.filter((_, idx) => idx !== index);\n}\nexport function addItem(array, item) {\n  return [...array, item];\n}\nexport function removeItem(array, item) {\n  return array.filter(eachItem => eachItem !== item);\n}\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\n\nexport function getNextIndex(currentIndex, length, step, loop) {\n  if (step === void 0) {\n    step = 1;\n  }\n  if (loop === void 0) {\n    loop = true;\n  }\n  var lastIndex = length - 1;\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex;\n  }\n  var nextIndex = currentIndex + step;\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0;\n  }\n  if (nextIndex >= length) {\n    if (loop) return 0;\n    return currentIndex > length ? length : currentIndex;\n  }\n  return nextIndex;\n}\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\n\nexport function getPrevIndex(index, count, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n  return getNextIndex(index, count, -1, loop);\n}\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\n\nexport function chunk(array, size) {\n  return array.reduce((rows, currentValue, index) => {\n    if (index % size === 0) {\n      rows.push([currentValue]);\n    } else {\n      rows[rows.length - 1].push(currentValue);\n    }\n    return rows;\n  }, []);\n}\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\n\nexport function getNextItemFromSearch(items, searchString, itemToString, currentItem) {\n  if (searchString == null) {\n    return currentItem;\n  } // If current item doesn't exist, find the item that matches the search string\n\n  if (!currentItem) {\n    var foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));\n    return foundItem;\n  } // Filter items for ones that match the search string (case insensitive)\n\n  var matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())); // If there's a match, let's get the next item to select\n\n  if (matchingItems.length > 0) {\n    var nextIndex; // If the currentItem is in the available items, we move to the next available option\n\n    if (matchingItems.includes(currentItem)) {\n      var currentIndex = matchingItems.indexOf(currentItem);\n      nextIndex = currentIndex + 1;\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0;\n      }\n      return matchingItems[nextIndex];\n    } // Else, we pick the first item in the available items\n\n    nextIndex = items.indexOf(matchingItems[0]);\n    return items[nextIndex];\n  } // a decent fallback to the currentItem\n\n  return currentItem;\n}","map":{"version":3,"sources":["../../src/array.ts"],"names":["getFirstItem","array","length","undefined","getLastItem","getPrevItem","index","loop","prevIndex","getPrevIndex","getNextItem","nextIndex","getNextIndex","removeIndex","filter","_","idx","addItem","item","removeItem","eachItem","currentIndex","step","lastIndex","count","chunk","size","reduce","rows","currentValue","push","getNextItemFromSearch","items","searchString","itemToString","currentItem","foundItem","find","toLowerCase","startsWith","matchingItems","includes","indexOf"],"mappings":"AAAA,OAAO,SAASA,YAAT,CAAyBC,KAAzB,EAAoD;EACzD,OAAOA,KAAK,IAAI,IAATA,IAAiBA,KAAK,CAACC,MAAvBD,GAAgCA,KAAK,CAAC,CAAD,CAArCA,GAA2CE,SAAlD;AACD;AAED,OAAO,SAASC,WAAT,CAAwBH,KAAxB,EAAmD;EACxD,IAAMC,MAAM,GAAGD,KAAK,IAAI,IAATA,GAAgB,CAAhBA,GAAoBA,KAAK,CAACC,MAAzC;EACA,OAAOA,MAAM,GAAGD,KAAK,CAACC,MAAM,GAAG,CAAV,CAAR,GAAuBC,SAApC;AACD;AAED,OAAO,SAASE,WAAT,CAAwBC,KAAxB,EAAuCL,KAAvC,EAAmDM,IAAnD,EAAmE;EAAA,IAAhBA,IAAgB,KAAA,KAAA,CAAA,EAAA;IAAhBA,IAAgB,GAAT,IAAS;EAAA;EACxE,IAAMC,SAAS,GAAGC,YAAY,CAACH,KAAD,EAAQL,KAAK,CAACC,MAAd,EAAsBK,IAAtB,CAA9B;EACA,OAAON,KAAK,CAACO,SAAD,CAAZ;AACD;AAED,OAAO,SAASE,WAAT,CAAwBJ,KAAxB,EAAuCL,KAAvC,EAAmDM,IAAnD,EAAmE;EAAA,IAAhBA,IAAgB,KAAA,KAAA,CAAA,EAAA;IAAhBA,IAAgB,GAAT,IAAS;EAAA;EACxE,IAAMI,SAAS,GAAGC,YAAY,CAACN,KAAD,EAAQL,KAAK,CAACC,MAAd,EAAsB,CAAtB,EAAyBK,IAAzB,CAA9B;EACA,OAAON,KAAK,CAACU,SAAD,CAAZ;AACD;AAED,OAAO,SAASE,WAAT,CAAwBZ,KAAxB,EAAoCK,KAApC,EAAwD;EAC7D,OAAOL,KAAK,CAACa,MAANb,CAAa,CAACc,CAAD,EAAIC,GAAJ,KAAYA,GAAG,KAAKV,KAAjCL,CAAP;AACD;AAED,OAAO,SAASgB,OAAT,CAAoBhB,KAApB,EAAgCiB,IAAhC,EAA8C;EACnD,OAAO,CAAC,GAAGjB,KAAJ,EAAWiB,IAAX,CAAP;AACD;AAED,OAAO,SAASC,UAAT,CAAuBlB,KAAvB,EAAmCiB,IAAnC,EAAiD;EACtD,OAAOjB,KAAK,CAACa,MAANb,CAAcmB,QAAD,IAAcA,QAAQ,KAAKF,IAAxCjB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASW,YAAT,CACLS,YADK,EAELnB,MAFK,EAGLoB,IAHK,EAILf,IAJK,EAKG;EAAA,IAFRe,IAEQ,KAAA,KAAA,CAAA,EAAA;IAFRA,IAEQ,GAFD,CAEC;EAAA;EAAA,IADRf,IACQ,KAAA,KAAA,CAAA,EAAA;IADRA,IACQ,GADD,IACC;EAAA;EACR,IAAMgB,SAAS,GAAGrB,MAAM,GAAG,CAA3B;EAEA,IAAImB,YAAY,KAAK,CAAC,CAAtB,EAAyB;IACvB,OAAOC,IAAI,GAAG,CAAPA,GAAW,CAAXA,GAAeC,SAAtB;EACD;EAED,IAAMZ,SAAS,GAAGU,YAAY,GAAGC,IAAjC;EAEA,IAAIX,SAAS,GAAG,CAAhB,EAAmB;IACjB,OAAOJ,IAAI,GAAGgB,SAAH,GAAe,CAA1B;EACD;EAED,IAAIZ,SAAS,IAAIT,MAAjB,EAAyB;IACvB,IAAIK,IAAJ,EAAU,OAAO,CAAP;IACV,OAAOc,YAAY,GAAGnB,MAAfmB,GAAwBnB,MAAxBmB,GAAiCA,YAAxC;EACD;EAED,OAAOV,SAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASF,YAAT,CACLH,KADK,EAELkB,KAFK,EAGLjB,IAHK,EAIG;EAAA,IADRA,IACQ,KAAA,KAAA,CAAA,EAAA;IADRA,IACQ,GADD,IACC;EAAA;EACR,OAAOK,YAAY,CAACN,KAAD,EAAQkB,KAAR,EAAe,CAAC,CAAhB,EAAmBjB,IAAnB,CAAnB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkB,KAAT,CAAkBxB,KAAlB,EAA8ByB,IAA9B,EAAmD;EACxD,OAAO,KAAK,CAACC,MAAN,CAAa,CAACC,IAAD,EAAcC,YAAd,EAA+BvB,KAA/B,KAAiD;IACnE,IAAIA,KAAK,GAAGoB,IAARpB,KAAiB,CAArB,EAAwB;MACtBsB,IAAI,CAACE,IAALF,CAAU,CAACC,YAAD,CAAVD,CAAAA;IACD,CAFD,MAEO;MACLA,IAAI,CAACA,IAAI,CAAC1B,MAAL0B,GAAc,CAAf,CAAJA,CAAsBE,IAAtBF,CAA2BC,YAA3BD,CAAAA;IACD;IACD,OAAOA,IAAP;EACD,CAPM,EAOJ,EAPI,CAAP;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,qBAAT,CACLC,KADK,EAELC,YAFK,EAGLC,YAHK,EAILC,WAJK,EAKU;EACf,IAAIF,YAAY,IAAI,IAApB,EAA0B;IACxB,OAAOE,WAAP;EACD,CAHc,CAKf;;EACA,IAAI,CAACA,WAAL,EAAkB;IAChB,IAAMC,SAAS,GAAGJ,KAAK,CAACK,IAANL,CAAYd,IAAD,IAC3BgB,YAAY,CAAChB,IAAD,CAAZgB,CAAmBI,WAAnBJ,CAAAA,CAAAA,CAAiCK,UAAjCL,CAA4CD,YAAY,CAACK,WAAbL,CAAAA,CAA5CC,CADgBF,CAAlB;IAGA,OAAOI,SAAP;EACD,CAXc,CAaf;;EACA,IAAMI,aAAa,GAAGR,KAAK,CAAClB,MAANkB,CAAcd,IAAD,IACjCgB,YAAY,CAAChB,IAAD,CAAZgB,CAAmBI,WAAnBJ,CAAAA,CAAAA,CAAiCK,UAAjCL,CAA4CD,YAAY,CAACK,WAAbL,CAAAA,CAA5CC,CADoBF,CAAtB,CAde,CAkBf;;EACA,IAAIQ,aAAa,CAACtC,MAAdsC,GAAuB,CAA3B,EAA8B;IAC5B,IAAI7B,SAAJ,CAD4B,CAG5B;;IACA,IAAI6B,aAAa,CAACC,QAAdD,CAAuBL,WAAvBK,CAAJ,EAAyC;MACvC,IAAMnB,YAAY,GAAGmB,aAAa,CAACE,OAAdF,CAAsBL,WAAtBK,CAArB;MACA7B,SAAS,GAAGU,YAAY,GAAG,CAA3BV;MACA,IAAIA,SAAS,KAAK6B,aAAa,CAACtC,MAAhC,EAAwC;QACtCS,SAAS,GAAG,CAAZA;MACD;MACD,OAAO6B,aAAa,CAAC7B,SAAD,CAApB;IACD,CAX2B,CAY5B;;IACAA,SAAS,GAAGqB,KAAK,CAACU,OAANV,CAAcQ,aAAa,CAAC,CAAD,CAA3BR,CAAZrB;IACA,OAAOqB,KAAK,CAACrB,SAAD,CAAZ;EACD,CAlCc,CAoCf;;EACA,OAAOwB,WAAP;AACD","sourcesContent":["export function getFirstItem<T>(array: T[]): T | undefined {\n  return array != null && array.length ? array[0] : undefined\n}\n\nexport function getLastItem<T>(array: T[]): T | undefined {\n  const length = array == null ? 0 : array.length\n  return length ? array[length - 1] : undefined\n}\n\nexport function getPrevItem<T>(index: number, array: T[], loop = true): T {\n  const prevIndex = getPrevIndex(index, array.length, loop)\n  return array[prevIndex]\n}\n\nexport function getNextItem<T>(index: number, array: T[], loop = true): T {\n  const nextIndex = getNextIndex(index, array.length, 1, loop)\n  return array[nextIndex]\n}\n\nexport function removeIndex<T>(array: T[], index: number): T[] {\n  return array.filter((_, idx) => idx !== index)\n}\n\nexport function addItem<T>(array: T[], item: T): T[] {\n  return [...array, item]\n}\n\nexport function removeItem<T>(array: T[], item: T): T[] {\n  return array.filter((eachItem) => eachItem !== item)\n}\n\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\nexport function getNextIndex(\n  currentIndex: number,\n  length: number,\n  step = 1,\n  loop = true,\n): number {\n  const lastIndex = length - 1\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex\n  }\n\n  const nextIndex = currentIndex + step\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0\n    return currentIndex > length ? length : currentIndex\n  }\n\n  return nextIndex\n}\n\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\nexport function getPrevIndex(\n  index: number,\n  count: number,\n  loop = true,\n): number {\n  return getNextIndex(index, count, -1, loop)\n}\n\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  return array.reduce((rows: T[][], currentValue: T, index: number) => {\n    if (index % size === 0) {\n      rows.push([currentValue])\n    } else {\n      rows[rows.length - 1].push(currentValue)\n    }\n    return rows\n  }, [] as T[][])\n}\n\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\nexport function getNextItemFromSearch<T>(\n  items: T[],\n  searchString: string,\n  itemToString: (item: T) => string,\n  currentItem: T,\n): T | undefined {\n  if (searchString == null) {\n    return currentItem\n  }\n\n  // If current item doesn't exist, find the item that matches the search string\n  if (!currentItem) {\n    const foundItem = items.find((item) =>\n      itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n    )\n    return foundItem\n  }\n\n  // Filter items for ones that match the search string (case insensitive)\n  const matchingItems = items.filter((item) =>\n    itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n  )\n\n  // If there's a match, let's get the next item to select\n  if (matchingItems.length > 0) {\n    let nextIndex: number\n\n    // If the currentItem is in the available items, we move to the next available option\n    if (matchingItems.includes(currentItem)) {\n      const currentIndex = matchingItems.indexOf(currentItem)\n      nextIndex = currentIndex + 1\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0\n      }\n      return matchingItems[nextIndex]\n    }\n    // Else, we pick the first item in the available items\n    nextIndex = items.indexOf(matchingItems[0])\n    return items[nextIndex]\n  }\n\n  // a decent fallback to the currentItem\n  return currentItem\n}\n"]},"metadata":{},"sourceType":"module"}