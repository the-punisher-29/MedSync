{"ast":null,"code":"import { getLastItem } from \"./array\";\nimport { isArray, isObject } from \"./assertion\";\nimport { objectKeys } from \"./object\";\nexport var breakpoints = Object.freeze([\"base\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\"]);\nexport function mapResponsive(prop, mapper) {\n  if (isArray(prop)) {\n    return prop.map(item => {\n      if (item === null) {\n        return null;\n      }\n      return mapper(item);\n    });\n  }\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result, key) => {\n      result[key] = mapper(prop[key]);\n      return result;\n    }, {});\n  }\n  if (prop != null) {\n    return mapper(prop);\n  }\n  return null;\n}\nexport function objectToArrayNotation(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n  var result = bps.map(br => {\n    var _obj$br;\n    return (_obj$br = obj[br]) != null ? _obj$br : null;\n  });\n  while (getLastItem(result) === null) {\n    result.pop();\n  }\n  return result;\n}\nexport function arrayToObjectNotation(values, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n  var result = {};\n  values.forEach((value, index) => {\n    var key = bps[index];\n    if (value == null) return;\n    result[key] = value;\n  });\n  return result;\n}\nexport function isResponsiveObjectLike(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n  var keys = Object.keys(obj);\n  return keys.length > 0 && keys.every(key => bps.includes(key));\n}\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\n\nexport var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));","map":{"version":3,"sources":["../../src/responsive.ts"],"names":["getLastItem","isArray","isObject","objectKeys","breakpoints","Object","freeze","mapResponsive","prop","mapper","map","item","reduce","result","key","objectToArrayNotation","obj","bps","br","pop","arrayToObjectNotation","values","forEach","value","index","isResponsiveObjectLike","keys","length","every","includes","isCustomBreakpoint","maybeBreakpoint","Number","isNaN"],"mappings":"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","sourcesContent":["import { getLastItem } from \"./array\"\nimport { isArray, isObject } from \"./assertion\"\nimport { objectKeys } from \"./object\"\nimport { Dict } from \"./types\"\n\nexport const breakpoints = Object.freeze([\n  \"base\",\n  \"sm\",\n  \"md\",\n  \"lg\",\n  \"xl\",\n  \"2xl\",\n])\n\nexport function mapResponsive(prop: any, mapper: (val: any) => any) {\n  if (isArray(prop)) {\n    return prop.map((item) => {\n      if (item === null) {\n        return null\n      }\n      return mapper(item)\n    })\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result: Dict, key) => {\n      result[key] = mapper(prop[key])\n      return result\n    }, {})\n  }\n\n  if (prop != null) {\n    return mapper(prop)\n  }\n\n  return null\n}\n\nexport function objectToArrayNotation(obj: Dict, bps = breakpoints) {\n  const result = bps.map((br) => obj[br] ?? null)\n  while (getLastItem(result) === null) {\n    result.pop()\n  }\n  return result\n}\n\nexport function arrayToObjectNotation(values: any[], bps = breakpoints) {\n  const result = {} as Dict\n  values.forEach((value, index) => {\n    const key = bps[index]\n    if (value == null) return\n    result[key] = value\n  })\n  return result\n}\n\nexport function isResponsiveObjectLike(obj: Dict, bps = breakpoints) {\n  const keys = Object.keys(obj)\n  return keys.length > 0 && keys.every((key) => bps.includes(key))\n}\n\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\nexport const isCustomBreakpoint = (maybeBreakpoint: string) =>\n  Number.isNaN(Number(maybeBreakpoint))\n"]},"metadata":{},"sourceType":"module"}