{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { useBoolean, useCallbackRef, useControllableState, useDimensions, useIds, useLatestRef, usePanGesture, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { mergeRefs } from \"@chakra-ui/react-utils\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, getBox, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { getStyles, getIsReversed } from \"./slider-utils\";\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props) {\n  var _getAriaValueText;\n  var {\n      min = 0,\n      max = 100,\n      onChange,\n      value: valueProp,\n      defaultValue,\n      isReversed: isReversedProp,\n      direction = \"ltr\",\n      orientation = \"horizontal\",\n      id: idProp,\n      isDisabled,\n      isReadOnly,\n      onChangeStart: onChangeStartProp,\n      onChangeEnd: onChangeEndProp,\n      step = 1,\n      getAriaValueText: getAriaValueTextProp,\n      \"aria-valuetext\": ariaValueText,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      name,\n      focusThumbOnChange = true\n    } = props,\n    htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"direction\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\"]);\n  var onChangeStart = useCallbackRef(onChangeStartProp);\n  var onChangeEnd = useCallbackRef(onChangeEndProp);\n  var getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  var isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n\n  var [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange\n  });\n  var [isDragging, setDragging] = useBoolean();\n  var [isFocused, setFocused] = useBoolean();\n  var eventSourceRef = useRef(null);\n  var isInteractive = !(isDisabled || isReadOnly);\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n\n  var value = clampValue(computedValue, min, max);\n  var valueRef = useLatestRef(value);\n  var prevRef = useRef(valueRef.current);\n  var reversedValue = max - value + min;\n  var trackValue = isReversed ? reversedValue : value;\n  var thumbPercent = valueToPercent(trackValue, min, max);\n  var isVertical = orientation === \"vertical\";\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var thumbRef = useRef(null);\n  var rootRef = useRef(null);\n  /**\n   * Generate unique ids for component parts\n   */\n\n  var [thumbId, trackId] = useIds(idProp, \"slider-thumb\", \"slider-track\");\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  var getValueFromPointer = useCallback(event => {\n    var _event$touches$, _event$touches;\n    if (!trackRef.current) return;\n    eventSourceRef.current = \"pointer\";\n    var trackRect = getBox(trackRef.current).borderBox;\n    var {\n      clientX,\n      clientY\n    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;\n    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    var length = isVertical ? trackRect.height : trackRect.width;\n    var percent = diff / length;\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n    var nextValue = percentToValue(percent, min, max);\n    if (step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, min, step));\n    }\n    nextValue = clampValue(nextValue, min, max);\n    return nextValue;\n  }, [isVertical, isReversed, max, min, step]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var constrain = useCallback(value => {\n    if (!isInteractive) return;\n    value = parseFloat(roundValueToStep(value, min, oneStep));\n    value = clampValue(value, min, max);\n    setValue(value);\n  }, [oneStep, max, min, setValue, isInteractive]);\n  var actions = useMemo(() => ({\n    stepUp: function stepUp(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n      var next = isReversed ? value - step : value + step;\n      constrain(next);\n    },\n    stepDown: function stepDown(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n      var next = isReversed ? value + step : value - step;\n      constrain(next);\n    },\n    reset: () => constrain(defaultValue || 0),\n    stepTo: value => constrain(value)\n  }), [constrain, isReversed, value, oneStep, defaultValue]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => actions.stepUp(),\n      ArrowUp: () => actions.stepUp(),\n      ArrowLeft: () => actions.stepDown(),\n      ArrowDown: () => actions.stepDown(),\n      PageUp: () => actions.stepUp(tenSteps),\n      PageDown: () => actions.stepDown(tenSteps),\n      Home: () => constrain(min),\n      End: () => constrain(max)\n    };\n    var action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      eventSourceRef.current = \"keyboard\";\n    }\n  }, [actions, constrain, max, min, tenSteps]);\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n\n  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n\n  var thumbBoxModel = useDimensions(thumbRef);\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => {\n    var _thumbBoxModel$border;\n    var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {\n      width: 0,\n      height: 0\n    };\n    return getStyles({\n      isReversed,\n      orientation,\n      thumbRects: [thumbRect],\n      thumbPercents: [thumbPercent]\n    });\n  }, [isReversed, orientation, thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox, thumbPercent]);\n  var focusThumb = useCallback(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(() => focus(thumbRef.current));\n    }\n  }, [focusThumbOnChange]);\n  useUpdateEffect(() => {\n    focusThumb();\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    }\n  }, [value, onChangeEnd]);\n  var setValueFromPointer = event => {\n    var nextValue = getValueFromPointer(event);\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue);\n    }\n  };\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging.on();\n      focusThumb();\n      setValueFromPointer(event);\n      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging.off();\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n      prevRef.current = valueRef.current;\n    },\n    onPan(event) {\n      if (!isInteractive) return;\n      setValueFromPointer(event);\n    }\n  });\n  var getRootProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, htmlProps, {\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  }, [htmlProps, isDisabled, isFocused, rootStyle]);\n  var getTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  }, [isDisabled, trackId, trackStyle]);\n  var getInnerTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  }, [innerTrackStyle]);\n  var getThumbProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: _extends({}, props.style, getThumbStyle(0)),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off)\n    });\n  }, [isInteractive, thumbId, isDragging, valueText, min, max, value, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused.on, setFocused.off]);\n  var getMarkerProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    var isInRange = !(props.value < min || props.value > max);\n    var isHighlighted = value >= props.value;\n    var markerPercent = valueToPercent(props.value, min, max);\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation,\n      vertical: {\n        bottom: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      },\n      horizontal: {\n        left: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      }\n    }));\n    return _extends({}, props, {\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  }, [isDisabled, isReversed, max, min, orientation, value]);\n  var getInputProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref,\n      type: \"hidden\",\n      value,\n      name\n    });\n  }, [name, value]);\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps\n  };\n}\nfunction orient(options) {\n  var {\n    orientation,\n    vertical,\n    horizontal\n  } = options;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}","map":{"version":3,"sources":["../../src/use-slider.ts"],"names":["useBoolean","useCallbackRef","useControllableState","useDimensions","useIds","useLatestRef","usePanGesture","useUpdateEffect","mergeRefs","ariaAttr","callAllHandlers","clampValue","dataAttr","focus","getBox","normalizeEventKey","percentToValue","roundValueToStep","valueToPercent","useCallback","useMemo","useRef","getStyles","getIsReversed","useSlider","props","min","max","onChange","value","valueProp","defaultValue","isReversed","isReversedProp","direction","orientation","id","idProp","isDisabled","isReadOnly","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","step","getAriaValueText","getAriaValueTextProp","ariaValueText","ariaLabel","ariaLabelledBy","name","focusThumbOnChange","htmlProps","computedValue","setValue","getDefaultValue","isDragging","setDragging","isFocused","setFocused","eventSourceRef","isInteractive","valueRef","prevRef","current","reversedValue","trackValue","thumbPercent","isVertical","trackRef","thumbRef","rootRef","thumbId","trackId","getValueFromPointer","event","trackRect","borderBox","clientX","clientY","touches","diff","bottom","left","length","height","width","percent","nextValue","parseFloat","tenSteps","oneStep","constrain","actions","stepUp","next","stepDown","reset","stepTo","onKeyDown","eventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","preventDefault","stopPropagation","valueText","thumbBoxModel","getThumbStyle","rootStyle","trackStyle","innerTrackStyle","thumbRect","thumbRects","thumbPercents","focusThumb","setTimeout","setValueFromPointer","onPanSessionStart","on","onPanSessionEnd","off","onPan","getRootProps","ref","tabIndex","style","getTrackProps","getInnerTrackProps","getThumbProps","role","undefined","onFocus","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","position","pointerEvents","orient","vertical","horizontal","getInputProps","type","state","options"],"mappings":"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","sourcesContent":["import {\n  useBoolean,\n  useCallbackRef,\n  useControllableState,\n  useDimensions,\n  useIds,\n  useLatestRef,\n  usePanGesture,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport { EventKeyMap, mergeRefs, PropGetter } from \"@chakra-ui/react-utils\"\nimport {\n  AnyPointerEvent,\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  focus,\n  getBox,\n  normalizeEventKey,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { CSSProperties, useCallback, useMemo, useRef } from \"react\"\nimport { getStyles, getIsReversed } from \"./slider-utils\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n  direction?: \"ltr\" | \"rtl\"\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  const [isDragging, setDragging] = useBoolean()\n\n  const [isFocused, setFocused] = useBoolean()\n  const eventSourceRef = useRef<\"pointer\" | \"keyboard\" | null>(null)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const valueRef = useLatestRef(value)\n\n  const prevRef = useRef(valueRef.current)\n\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const thumbPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<any>(null)\n  const thumbRef = useRef<any>(null)\n  const rootRef = useRef<any>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`)\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return\n      eventSourceRef.current = \"pointer\"\n      const trackRect = getBox(trackRef.current).borderBox\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) {\n        nextValue = parseFloat(roundValueToStep(nextValue, min, step))\n      }\n\n      nextValue = clampValue(nextValue, min, max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, max, min, step],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const constrain = useCallback(\n    (value: number) => {\n      if (!isInteractive) return\n      value = parseFloat(roundValueToStep(value, min, oneStep))\n      value = clampValue(value, min, max)\n      setValue(value)\n    },\n    [oneStep, max, min, setValue, isInteractive],\n  )\n\n  const actions = useMemo(\n    () => ({\n      stepUp: (step = oneStep) => {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown: (step = oneStep) => {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset: () => constrain(defaultValue || 0),\n      stepTo: (value: number) => constrain(value),\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        eventSourceRef.current = \"keyboard\"\n      }\n    },\n    [actions, constrain, max, min, tenSteps],\n  )\n\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n  const thumbBoxModel = useDimensions(thumbRef)\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle,\n  } = useMemo(() => {\n    const thumbRect = thumbBoxModel?.borderBox ?? { width: 0, height: 0 }\n    return getStyles({\n      isReversed,\n      orientation,\n      thumbRects: [thumbRect],\n      thumbPercents: [thumbPercent],\n    })\n  }, [isReversed, orientation, thumbBoxModel?.borderBox, thumbPercent])\n\n  const focusThumb = useCallback(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(() => focus(thumbRef.current))\n    }\n  }, [focusThumbOnChange])\n\n  useUpdateEffect(() => {\n    focusThumb()\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd?.(valueRef.current)\n    }\n  }, [value, onChangeEnd])\n\n  const setValueFromPointer = (event: AnyPointerEvent) => {\n    const nextValue = getValueFromPointer(event)\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue)\n    }\n  }\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging.on()\n      focusThumb()\n      setValueFromPointer(event)\n      onChangeStart?.(valueRef.current)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging.off()\n      onChangeEnd?.(valueRef.current)\n      prevRef.current = valueRef.current\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      setValueFromPointer(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...htmlProps,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: {\n        ...props.style,\n        ...rootStyle,\n      },\n    }),\n    [htmlProps, isDisabled, isFocused, rootStyle],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: {\n        ...props.style,\n        ...trackStyle,\n      },\n    }),\n    [isDisabled, trackId, trackStyle],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      style: {\n        ...props.style,\n        ...innerTrackStyle,\n      },\n    }),\n    [innerTrackStyle],\n  )\n\n  const getThumbProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: {\n        ...props.style,\n        ...getThumbStyle(0),\n      },\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off),\n    }),\n    [\n      isInteractive,\n      thumbId,\n      isDragging,\n      valueText,\n      min,\n      max,\n      value,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused.on,\n      setFocused.off,\n    ],\n  )\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = useCallback(\n    (props = {}, ref = null) => {\n      const isInRange = !(props.value < min || props.value > max)\n      const isHighlighted = value >= props.value\n      const markerPercent = valueToPercent(props.value, min, max)\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: {\n            bottom: isReversed\n              ? `${100 - markerPercent}%`\n              : `${markerPercent}%`,\n          },\n          horizontal: {\n            left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n          },\n        }),\n      }\n\n      return {\n        ...props,\n        ref,\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value],\n  )\n\n  const getInputProps: PropGetter<HTMLInputElement> = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      type: \"hidden\",\n      value,\n      name,\n    }),\n    [name, value],\n  )\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: CSSProperties\n  horizontal: CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"]},"metadata":{},"sourceType":"module"}