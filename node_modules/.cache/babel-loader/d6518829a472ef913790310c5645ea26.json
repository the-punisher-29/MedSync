{"ast":null,"code":"import { useCallbackRef, useControllableProp } from \"@chakra-ui/hooks\";\nimport { clampValue, countDecimalPlaces, maxSafeInteger, minSafeInteger, toPrecision } from \"@chakra-ui/utils\";\nimport { useCallback, useState } from \"react\";\nexport function useCounter(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  var {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true\n  } = props;\n  var onChangeProp = useCallbackRef(onChange);\n  var [valueState, setValue] = useState(() => {\n    var _cast;\n    if (defaultValue == null) return \"\";\n    return (_cast = cast(defaultValue, stepProp, precisionProp)) != null ? _cast : \"\";\n  });\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n\n  var [isControlled, value] = useControllableProp(valueProp, valueState);\n  var decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  var precision = precisionProp != null ? precisionProp : decimalPlaces;\n  var update = useCallback(next => {\n    if (next === value) return;\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]); // Function to clamp the value and round it to the precision\n\n  var clamp = useCallback(value => {\n    var nextValue = value;\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  var increment = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n    var next;\n    /**\n     * Let's follow the native browser behavior for\n     * scenarios where the input starts empty (\"\")\n     */\n\n    if (value === \"\") {\n      /**\n       * If `min` is set, native input, starts at the `min`.\n       * Else, it starts at `step`\n       */\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var decrement = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n    var next; // Same thing here. We'll follow native implementation\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var reset = useCallback(() => {\n    var next;\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      var _cast2;\n      next = (_cast2 = cast(defaultValue, stepProp, precisionProp)) != null ? _cast2 : min;\n    }\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  var castValue = useCallback(value => {\n    var _cast3;\n    var nextValue = (_cast3 = cast(value, stepProp, precision)) != null ? _cast3 : min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  var valueAsNumber = parse(value);\n  /**\n   * Common range checks\n   */\n\n  var isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  var isAtMax = valueAsNumber === max;\n  var isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue\n  };\n}\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\nfunction cast(value, step, precision) {\n  var parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return undefined;\n  var decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return toPrecision(parsedValue, precision != null ? precision : decimalPlaces);\n}","map":{"version":3,"sources":["../../src/use-counter.ts"],"names":["useCallbackRef","useControllableProp","clampValue","countDecimalPlaces","maxSafeInteger","minSafeInteger","toPrecision","useCallback","useState","useCounter","props","onChange","precision","precisionProp","defaultValue","value","valueProp","step","stepProp","min","max","keepWithinRange","onChangeProp","valueState","setValue","cast","isControlled","decimalPlaces","getDecimalPlaces","parse","update","next","toString","clamp","nextValue","increment","decrement","reset","castValue","valueAsNumber","isOutOfRange","isAtMax","isAtMin","parseFloat","replace","Math","parsedValue","Number","isNaN","undefined"],"mappings":"AAAA,SAASA,cAAT,EAAyBC,mBAAzB,QAAoD,kBAApD;AACA,SACEC,UADF,EAEEC,kBAFF,EAGEC,cAHF,EAIEC,cAJF,EAMEC,WANF,QAOO,kBAPP;AAQA,SAASC,WAAT,EAAsBC,QAAtB,QAAsC,OAAtC;AA+CA,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAAiD;EAAA,IAA7BA,KAA6B,KAAA,KAAA,CAAA,EAAA;IAA7BA,KAA6B,GAAJ,CAAA,CAAI;EAAA;EACtD,IAAM;IACJC,QADI;IAEJC,SAAS,EAAEC,aAFP;IAGJC,YAHI;IAIJC,KAAK,EAAEC,SAJH;IAKJC,IAAI,EAAEC,QAAQ,GAAG,CALb;IAMJC,GAAG,GAAGd,cANF;IAOJe,GAAG,GAAGhB,cAPF;IAQJiB,eAAe,GAAG;EARd,CAAA,GASFX,KATJ;EAWA,IAAMY,YAAY,GAAGtB,cAAc,CAACW,QAAD,CAAnC;EAEA,IAAM,CAACY,UAAD,EAAaC,QAAb,CAAA,GAAyBhB,QAAQ,CAAiB,MAAM;IAAA,IAAA,KAAA;IAC5D,IAAIM,YAAY,IAAI,IAApB,EAA0B,OAAO,EAAP;IAC1B,OAAA,CAAA,KAAA,GAAOW,IAAI,CAACX,YAAD,EAAeI,QAAf,EAAyBL,aAAzB,CAAX,KAAA,IAAA,GAAA,KAAA,GAAsD,EAAtD;EACD,CAHsC,CAAvC;EAKA;AACF;AACA;AACA;;EACE,IAAM,CAACa,YAAD,EAAeX,KAAf,CAAA,GAAwBd,mBAAmB,CAACe,SAAD,EAAYO,UAAZ,CAAjD;EAEA,IAAMI,aAAa,GAAGC,gBAAgB,CAACC,KAAK,CAACd,KAAD,CAAN,EAAeG,QAAf,CAAtC;EAEA,IAAMN,SAAS,GAAGC,aAAH,IAAA,IAAA,GAAGA,aAAH,GAAoBc,aAAnC;EAEA,IAAMG,MAAM,GAAGvB,WAAW,CACvBwB,IAAD,IAA0B;IACxB,IAAIA,IAAI,KAAKhB,KAAb,EAAoB;IACpB,IAAI,CAACW,YAAL,EAAmB;MACjBF,QAAQ,CAACO,IAAI,CAACC,QAALD,CAAAA,CAAD,CAARP;IACD;IACDF,YAAY,IAAA,IAAZA,GAAAA,KAAAA,CAAAA,GAAAA,YAAY,CAAGS,IAAI,CAACC,QAALD,CAAAA,CAAH,EAAoBF,KAAK,CAACE,IAAD,CAAzB,CAAZT;EACD,CAPuB,EAQxB,CAACA,YAAD,EAAeI,YAAf,EAA6BX,KAA7B,CARwB,CAA1B,CA7BsD,CAwCtD;;EACA,IAAMkB,KAAK,GAAG1B,WAAW,CACtBQ,KAAD,IAAmB;IACjB,IAAImB,SAAS,GAAGnB,KAAhB;IAEA,IAAIM,eAAJ,EAAqB;MACnBa,SAAS,GAAGhC,UAAU,CAACgC,SAAD,EAAYf,GAAZ,EAAiBC,GAAjB,CAAtBc;IACD;IAED,OAAO5B,WAAW,CAAC4B,SAAD,EAAYtB,SAAZ,CAAlB;EACD,CATsB,EAUvB,CAACA,SAAD,EAAYS,eAAZ,EAA6BD,GAA7B,EAAkCD,GAAlC,CAVuB,CAAzB;EAaA,IAAMgB,SAAS,GAAG5B,WAAW,CAC3B,UAACU,IAAD,EAAqB;IAAA,IAApBA,IAAoB,KAAA,KAAA,CAAA,EAAA;MAApBA,IAAoB,GAAbC,QAAa;IAAA;IACnB,IAAIa,IAAJ;IAEA;AACN;AACA;AACA;;IACM,IAAIhB,KAAK,KAAK,EAAd,EAAkB;MAChB;AACR;AACA;AACA;MACQgB,IAAI,GAAGF,KAAK,CAACZ,IAAD,CAAZc;IACD,CAND,MAMO;MACLA,IAAI,GAAGF,KAAK,CAACd,KAAD,CAALc,GAAeZ,IAAtBc;IACD;IAEDA,IAAI,GAAGE,KAAK,CAACF,IAAD,CAAZA;IACAD,MAAM,CAACC,IAAD,CAAND;EACD,CApB0B,EAqB3B,CAACG,KAAD,EAAQf,QAAR,EAAkBY,MAAlB,EAA0Bf,KAA1B,CArB2B,CAA7B;EAwBA,IAAMqB,SAAS,GAAG7B,WAAW,CAC3B,UAACU,IAAD,EAAqB;IAAA,IAApBA,IAAoB,KAAA,KAAA,CAAA,EAAA;MAApBA,IAAoB,GAAbC,QAAa;IAAA;IACnB,IAAIa,IAAJ,CADmB,CAGnB;;IACA,IAAIhB,KAAK,KAAK,EAAd,EAAkB;MAChBgB,IAAI,GAAGF,KAAK,CAAC,CAACZ,IAAF,CAAZc;IACD,CAFD,MAEO;MACLA,IAAI,GAAGF,KAAK,CAACd,KAAD,CAALc,GAAeZ,IAAtBc;IACD;IAEDA,IAAI,GAAGE,KAAK,CAACF,IAAD,CAAZA;IACAD,MAAM,CAACC,IAAD,CAAND;EACD,CAb0B,EAc3B,CAACG,KAAD,EAAQf,QAAR,EAAkBY,MAAlB,EAA0Bf,KAA1B,CAd2B,CAA7B;EAiBA,IAAMsB,KAAK,GAAG9B,WAAW,CAAC,MAAM;IAC9B,IAAIwB,IAAJ;IACA,IAAIjB,YAAY,IAAI,IAApB,EAA0B;MACxBiB,IAAI,GAAG,EAAPA;IACD,CAFD,MAEO;MAAA,IAAA,MAAA;MACLA,IAAI,GAAA,CAAA,MAAA,GAAGN,IAAI,CAACX,YAAD,EAAeI,QAAf,EAAyBL,aAAzB,CAAP,KAAA,IAAA,GAAA,MAAA,GAAkDM,GAAtDY;IACD;IACDD,MAAM,CAACC,IAAD,CAAND;EACD,CARwB,EAQtB,CAAChB,YAAD,EAAeD,aAAf,EAA8BK,QAA9B,EAAwCY,MAAxC,EAAgDX,GAAhD,CARsB,CAAzB;EAUA,IAAMmB,SAAS,GAAG/B,WAAW,CAC1BQ,KAAD,IAA2B;IAAA,IAAA,MAAA;IACzB,IAAMmB,SAAS,GAAA,CAAA,MAAA,GAAGT,IAAI,CAACV,KAAD,EAAQG,QAAR,EAAkBN,SAAlB,CAAP,KAAA,IAAA,GAAA,MAAA,GAAuCO,GAAtD;IACAW,MAAM,CAACI,SAAD,CAANJ;EACD,CAJ0B,EAK3B,CAAClB,SAAD,EAAYM,QAAZ,EAAsBY,MAAtB,EAA8BX,GAA9B,CAL2B,CAA7B;EAQA,IAAMoB,aAAa,GAAGV,KAAK,CAACd,KAAD,CAA3B;EAEA;AACF;AACA;;EACE,IAAMyB,YAAY,GAAGD,aAAa,GAAGnB,GAAhBmB,IAAuBA,aAAa,GAAGpB,GAA5D;EACA,IAAMsB,OAAO,GAAGF,aAAa,KAAKnB,GAAlC;EACA,IAAMsB,OAAO,GAAGH,aAAa,KAAKpB,GAAlC;EAEA,OAAO;IACLqB,YADK;IAELC,OAFK;IAGLC,OAHK;IAIL9B,SAJK;IAKLG,KALK;IAMLwB,aANK;IAOLT,MAPK;IAQLO,KARK;IASLF,SATK;IAULC,SAVK;IAWLH,KAXK;IAYLR,IAAI,EAAEa,SAZD;IAaLd;EAbK,CAAP;AAeD;AAID,SAASK,KAAT,CAAed,KAAf,EAAsC;EACpC,OAAO4B,UAAU,CAAC5B,KAAK,CAACiB,QAANjB,CAAAA,CAAAA,CAAiB6B,OAAjB7B,CAAyB,WAAzBA,EAAsC,EAAtCA,CAAD,CAAjB;AACD;AAED,SAASa,gBAAT,CAA0Bb,KAA1B,EAAyCE,IAAzC,EAAuD;EACrD,OAAO4B,IAAI,CAACzB,GAALyB,CAAS1C,kBAAkB,CAACc,IAAD,CAA3B4B,EAAmC1C,kBAAkB,CAACY,KAAD,CAArD8B,CAAP;AACD;AAED,SAASpB,IAAT,CAAcV,KAAd,EAAqCE,IAArC,EAAmDL,SAAnD,EAAuE;EACrE,IAAMkC,WAAW,GAAGjB,KAAK,CAACd,KAAD,CAAzB;EACA,IAAIgC,MAAM,CAACC,KAAPD,CAAaD,WAAbC,CAAJ,EAA+B,OAAOE,SAAP;EAC/B,IAAMtB,aAAa,GAAGC,gBAAgB,CAACkB,WAAD,EAAc7B,IAAd,CAAtC;EACA,OAAOX,WAAW,CAACwC,WAAD,EAAclC,SAAd,IAAA,IAAA,GAAcA,SAAd,GAA2Be,aAA3B,CAAlB;AACD","sourcesContent":["import { useCallbackRef, useControllableProp } from \"@chakra-ui/hooks\"\nimport {\n  clampValue,\n  countDecimalPlaces,\n  maxSafeInteger,\n  minSafeInteger,\n  StringOrNumber,\n  toPrecision,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useState } from \"react\"\n\nexport interface UseCounterProps {\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?(valueAsString: string, valueAsNumber: number): void\n  /**\n   * The number of decimal points used to round the value\n   */\n  precision?: number\n  /**\n   * The initial value of the counter. Should be less than `max` and greater than `min`\n   */\n  defaultValue?: StringOrNumber\n  /**\n   * The value of the counter. Should be less than `max` and greater than `min`\n   */\n  value?: StringOrNumber\n  /**\n   * The step used to increment or decrement the value\n   * @default 1\n   */\n  step?: number\n  /**\n   * The minimum value of the counter\n   * @default -Infinity\n   */\n  min?: number\n  /**\n   * The maximum value of the counter\n   * @default Infinity\n   */\n  max?: number\n  /**\n   * This controls the value update behavior in general.\n   *\n   * - If `true` and you use the stepper or up/down arrow keys,\n   *  the value will not exceed the `max` or go lower than `min`\n   *\n   * - If `false`, the value will be allowed to go out of range.\n   *\n   * @default true\n   */\n  keepWithinRange?: boolean\n}\n\nexport function useCounter(props: UseCounterProps = {}) {\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true,\n  } = props\n\n  const onChangeProp = useCallbackRef(onChange)\n\n  const [valueState, setValue] = useState<StringOrNumber>(() => {\n    if (defaultValue == null) return \"\"\n    return cast(defaultValue, stepProp, precisionProp) ?? \"\"\n  })\n\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n  const [isControlled, value] = useControllableProp(valueProp, valueState)\n\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp)\n\n  const precision = precisionProp ?? decimalPlaces\n\n  const update = useCallback(\n    (next: StringOrNumber) => {\n      if (next === value) return\n      if (!isControlled) {\n        setValue(next.toString())\n      }\n      onChangeProp?.(next.toString(), parse(next))\n    },\n    [onChangeProp, isControlled, value],\n  )\n\n  // Function to clamp the value and round it to the precision\n  const clamp = useCallback(\n    (value: number) => {\n      let nextValue = value\n\n      if (keepWithinRange) {\n        nextValue = clampValue(nextValue, min, max)\n      }\n\n      return toPrecision(nextValue, precision)\n    },\n    [precision, keepWithinRange, max, min],\n  )\n\n  const increment = useCallback(\n    (step = stepProp) => {\n      let next: StringOrNumber\n\n      /**\n       * Let's follow the native browser behavior for\n       * scenarios where the input starts empty (\"\")\n       */\n      if (value === \"\") {\n        /**\n         * If `min` is set, native input, starts at the `min`.\n         * Else, it starts at `step`\n         */\n        next = parse(step)\n      } else {\n        next = parse(value) + step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const decrement = useCallback(\n    (step = stepProp) => {\n      let next: StringOrNumber\n\n      // Same thing here. We'll follow native implementation\n      if (value === \"\") {\n        next = parse(-step)\n      } else {\n        next = parse(value) - step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const reset = useCallback(() => {\n    let next: StringOrNumber\n    if (defaultValue == null) {\n      next = \"\"\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp) ?? min\n    }\n    update(next)\n  }, [defaultValue, precisionProp, stepProp, update, min])\n\n  const castValue = useCallback(\n    (value: StringOrNumber) => {\n      const nextValue = cast(value, stepProp, precision) ?? min\n      update(nextValue)\n    },\n    [precision, stepProp, update, min],\n  )\n\n  const valueAsNumber = parse(value)\n\n  /**\n   * Common range checks\n   */\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min\n  const isAtMax = valueAsNumber === max\n  const isAtMin = valueAsNumber === min\n\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue,\n  }\n}\n\nexport type UseCounterReturn = ReturnType<typeof useCounter>\n\nfunction parse(value: StringOrNumber) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"))\n}\n\nfunction getDecimalPlaces(value: number, step: number) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value))\n}\n\nfunction cast(value: StringOrNumber, step: number, precision?: number) {\n  const parsedValue = parse(value)\n  if (Number.isNaN(parsedValue)) return undefined\n  const decimalPlaces = getDecimalPlaces(parsedValue, step)\n  return toPrecision(parsedValue, precision ?? decimalPlaces)\n}\n"]},"metadata":{},"sourceType":"module"}